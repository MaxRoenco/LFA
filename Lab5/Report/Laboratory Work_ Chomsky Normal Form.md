# Laboratory Work: Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Author: Roenco Maxim

## Abstract
This laboratory work focuses on implementing a method for converting context-free grammars to Chomsky Normal Form (CNF). The implementation includes all necessary steps: eliminating ε-productions, renaming productions, inaccessible symbols, and non-productive symbols. The final result is a grammar in CNF where all productions are of the form A → BC or A → a, where A, B, and C are non-terminals and a is a terminal.

## Introduction
Chomsky Normal Form is a simplified form of context-free grammars that is particularly useful for parsing algorithms like the CYK algorithm. Converting a grammar to CNF involves several transformation steps that preserve the language generated by the grammar while ensuring that all productions follow specific patterns.

In this laboratory work, I implement a Python solution that can convert any context-free grammar to CNF, with a specific focus on the grammar provided in Variant 25.

## Objectives
1. Learn about Chomsky Normal Form (CNF)
2. Get familiar with the approaches of normalizing a grammar
3. Implement a method for normalizing an input grammar by the rules of CNF
4. Test the implementation with the grammar from Variant 25 and other grammars

## Implementation Description

### Grammar Representation
The grammar is represented using a `Grammar` class that encapsulates the non-terminals, terminals, productions, and start symbol. The class provides methods for each transformation step in the conversion process.

```python
class Grammar:
    def __init__(self, non_terminals=None, terminals=None, productions=None, start_symbol=None):
        self.non_terminals = non_terminals if non_terminals else set()
        self.terminals = terminals if terminals else set()
        self.productions = productions if productions else {}
        self.start_symbol = start_symbol
```

### Step 1: Eliminating ε-productions
The first step in converting a grammar to CNF is to eliminate all ε-productions (productions of the form A → ε). This is done by:
1. Identifying all nullable symbols (symbols that can derive ε)
2. For each production containing nullable symbols, generating all possible combinations by removing these symbols
3. Adding these new productions to the grammar

```python
def eliminate_epsilon_productions(self):
    # Find all nullable symbols
    nullable = set()
    
    # Initially, add all symbols that directly produce ε
    for nt, prods in self.productions.items():
        if 'ε' in prods:
            nullable.add(nt)
    
    # Iteratively find all nullable symbols
    changed = True
    while changed:
        changed = False
        for nt, prods in self.productions.items():
            if nt in nullable:
                continue
            
            for prod in prods:
                if all(symbol in nullable for symbol in prod):
                    nullable.add(nt)
                    changed = True
                    break
    
    # Create new productions without ε-productions
    new_productions = {}
    
    for nt, prods in self.productions.items():
        new_prods = []
        
        for prod in prods:
            if prod == 'ε':
                continue  # Skip ε-productions
            
            # Generate all possible combinations by removing nullable symbols
            self._add_combinations(prod, nullable, 0, '', new_prods)
        
        if new_prods:
            new_productions[nt] = new_prods
    
    # Create a new grammar without ε-productions
    new_grammar = Grammar(
        non_terminals=self.non_terminals.copy(),
        terminals=self.terminals.copy(),
        productions=new_productions,
        start_symbol=self.start_symbol
    )
    
    # If the start symbol is nullable, add a new production S' → ε
    if self.start_symbol in nullable:
        if 'S0' not in new_grammar.non_terminals:
            new_grammar.non_terminals.add('S0')
            new_grammar.productions['S0'] = [self.start_symbol, 'ε']
            new_grammar.start_symbol = 'S0'
    
    return new_grammar
```

### Step 2: Eliminating Renaming (Unit Productions)
The next step is to eliminate unit productions (productions of the form A → B where B is a non-terminal). This is done by:
1. Finding all unit pairs (A, B) such that A ⇒* B
2. Replacing each unit production A → B with the productions A → α for each production B → α

```python
def eliminate_renaming(self):
    # Find all unit pairs (A, B) such that A =>* B
    unit_pairs = {}
    
    # Initialize with direct unit productions
    for nt in self.non_terminals:
        unit_pairs[nt] = {nt}  # Every non-terminal can derive itself
        
        if nt in self.productions:
            for prod in self.productions[nt]:
                if len(prod) == 1 and prod in self.non_terminals:
                    unit_pairs[nt].add(prod)
    
    # Find all unit pairs using transitive closure
    changed = True
    while changed:
        changed = False
        for a in self.non_terminals:
            for b in list(unit_pairs.get(a, set())):
                for c in list(unit_pairs.get(b, set())):
                    if c not in unit_pairs.get(a, set()):
                        if a not in unit_pairs:
                            unit_pairs[a] = set()
                        unit_pairs[a].add(c)
                        changed = True
    
    # Create new productions without unit productions
    new_productions = {}
    
    for a in self.non_terminals:
        new_prods = []
        
        for b in unit_pairs.get(a, set()):
            if b in self.productions:
                for prod in self.productions[b]:
                    # Skip unit productions
                    if len(prod) != 1 or prod not in self.non_terminals:
                        new_prods.append(prod)
        
        if new_prods:
            new_productions[a] = new_prods
    
    # Create a new grammar without unit productions
    return Grammar(
        non_terminals=self.non_terminals.copy(),
        terminals=self.terminals.copy(),
        productions=new_productions,
        start_symbol=self.start_symbol
    )
```

### Step 3: Eliminating Inaccessible Symbols
Inaccessible symbols are those that cannot be reached from the start symbol. To eliminate them:
1. Find all accessible symbols starting from the start symbol
2. Remove all productions containing inaccessible symbols

```python
def eliminate_inaccessible_symbols(self):
    # Find all accessible symbols starting from the start symbol
    accessible = {self.start_symbol}
    
    # Iteratively find all accessible symbols
    changed = True
    while changed:
        changed = False
        for nt in list(accessible):
            if nt in self.productions:
                for prod in self.productions[nt]:
                    for symbol in prod:
                        if symbol not in accessible and (symbol in self.non_terminals or symbol in self.terminals):
                            accessible.add(symbol)
                            changed = True
    
    # Create new sets of non-terminals and terminals
    new_non_terminals = self.non_terminals.intersection(accessible)
    new_terminals = self.terminals.intersection(accessible)
    
    # Create new productions without inaccessible symbols
    new_productions = {}
    for nt in new_non_terminals:
        if nt in self.productions:
            new_prods = []
            for prod in self.productions[nt]:
                # Check if all symbols in the production are accessible
                if all(symbol in accessible or symbol == 'ε' for symbol in prod):
                    new_prods.append(prod)
            
            if new_prods:
                new_productions[nt] = new_prods
    
    # Create a new grammar without inaccessible symbols
    return Grammar(
        non_terminals=new_non_terminals,
        terminals=new_terminals,
        productions=new_productions,
        start_symbol=self.start_symbol
    )
```

### Step 4: Eliminating Non-productive Symbols
Non-productive symbols are those that cannot derive any terminal string. To eliminate them:
1. Find all productive symbols (symbols that can derive terminal strings)
2. Remove all productions containing non-productive symbols

```python
def eliminate_non_productive_symbols(self):
    # Find all productive symbols
    productive = set()
    
    # Initially, add all terminals as productive
    for nt, prods in self.productions.items():
        for prod in prods:
            if all(symbol in self.terminals or symbol == 'ε' for symbol in prod):
                productive.add(nt)
                break
    
    # Iteratively find all productive symbols
    changed = True
    while changed:
        changed = False
        for nt, prods in self.productions.items():
            if nt in productive:
                continue
            
            for prod in prods:
                if all(symbol in productive or symbol in self.terminals or symbol == 'ε' for symbol in prod):
                    productive.add(nt)
                    changed = True
                    break
    
    # Create new sets of non-terminals
    new_non_terminals = self.non_terminals.intersection(productive)
    
    # Create new productions without non-productive symbols
    new_productions = {}
    for nt in new_non_terminals:
        if nt in self.productions:
            new_prods = []
            for prod in self.productions[nt]:
                # Check if all non-terminals in the production are productive
                if all(symbol in productive or symbol in self.terminals or symbol == 'ε' for symbol in prod):
                    new_prods.append(prod)
            
            if new_prods:
                new_productions[nt] = new_prods
    
    # Create a new grammar without non-productive symbols
    return Grammar(
        non_terminals=new_non_terminals,
        terminals=self.terminals.copy(),
        productions=new_productions,
        start_symbol=self.start_symbol if self.start_symbol in productive else None
    )
```

### Step 5: Converting to Chomsky Normal Form
The final step is to convert the grammar to CNF, where all productions are of the form A → BC or A → a:
1. Replace terminals in productions with new non-terminals
2. Break down productions with more than two symbols into binary productions

```python
def convert_to_cnf(self):
    # Step 1: Eliminate ε-productions
    grammar = self.eliminate_epsilon_productions()
    
    # Step 2: Eliminate renaming (unit productions)
    grammar = grammar.eliminate_renaming()
    
    # Step 3: Eliminate inaccessible symbols
    grammar = grammar.eliminate_inaccessible_symbols()
    
    # Step 4: Eliminate non-productive symbols
    grammar = grammar.eliminate_non_productive_symbols()
    
    # Step 5: Convert to CNF
    new_non_terminals = grammar.non_terminals.copy()
    new_productions = {}
    terminal_map = {}  # Maps terminals to new non-terminals
    
    # Initialize productions
    for nt in grammar.non_terminals:
        new_productions[nt] = []
    
    # Process each production
    for nt, prods in grammar.productions.items():
        for prod in prods:
            if len(prod) == 1 and prod in grammar.terminals:
                # Rule A → a (already in CNF)
                new_productions[nt].append(prod)
            elif len(prod) >= 2:
                # Convert to CNF
                new_prod = self._convert_production_to_cnf(prod, grammar.terminals, new_non_terminals, new_productions, terminal_map)
                new_productions[nt].append(new_prod)
    
    # Create a new grammar in CNF
    return Grammar(
        non_terminals=new_non_terminals,
        terminals=grammar.terminals.copy(),
        productions=new_productions,
        start_symbol=grammar.start_symbol
    )
```

### Helper Methods
Several helper methods are implemented to support the main transformation steps:

```python
def _add_combinations(self, prod, nullable, pos, current, result):
    """
    Helper method to generate all possible combinations by removing nullable symbols.
    """
    if pos == len(prod):
        if current:  # Don't add empty string as a production
            result.append(current)
        return
    
    symbol = prod[pos]
    
    # Always include the current symbol
    self._add_combinations(prod, nullable, pos + 1, current + symbol, result)
    
    # If the symbol is nullable, also try skipping it
    if symbol in nullable:
        self._add_combinations(prod, nullable, pos + 1, current, result)

def _convert_production_to_cnf(self, prod, terminals, non_terminals, productions, terminal_map):
    """
    Convert a production to CNF format.
    """
    # Replace terminals with new non-terminals
    symbols = []
    for symbol in prod:
        if symbol in terminals:
            if symbol not in terminal_map:
                new_nt = f"T_{symbol}"
                terminal_map[symbol] = new_nt
                non_terminals.add(new_nt)
                productions[new_nt] = [symbol]
            symbols.append(terminal_map[symbol])
        else:
            symbols.append(symbol)
    
    # If the production has only two symbols, it's already in CNF
    if len(symbols) == 2:
        return ''.join(symbols)
    
    # Otherwise, create new non-terminals for groups of symbols
    while len(symbols) > 2:
        new_nt = f"X_{len(non_terminals)}"
        non_terminals.add(new_nt)
        
        # Create a new production for the last two symbols
        last_two = ''.join(symbols[-2:])
        productions[new_nt] = [last_two]
        
        # Replace the last two symbols with the new non-terminal
        symbols = symbols[:-2] + [new_nt]
    
    return ''.join(symbols)
```

### Factory Methods
To make the implementation more flexible, factory methods are provided to create grammars from different sources:

```python
@classmethod
def from_variant_25(cls):
    """
    Create a Grammar object from the grammar specified in Variant 25.
    """
    non_terminals = {'S', 'A', 'B', 'C', 'D'}
    terminals = {'a', 'b'}
    productions = {
        'S': ['bA', 'BC'],
        'A': ['a', 'aS', 'bCaCa'],
        'B': ['A', 'bS', 'bCAa'],
        'C': ['ε', 'AB'],
        'D': ['AB']
    }
    start_symbol = 'S'
    
    return cls(non_terminals, terminals, productions, start_symbol)

@classmethod
def from_string(cls, grammar_str):
    """
    Create a Grammar object from a string representation.
    """
    # Implementation details...
```

## Results and Analysis
Let's analyze the transformation of the grammar from Variant 25 through each step of the conversion process.

### Original Grammar
```
G=(VN, VT, P, S) VN={S, A, B, C, D} VT={a, b}
P={1. S→bA                     5. A→bCaCa               9. C→ε
   2. S→BC                     6. B→A                   10. C→AB
   3. A→a                      7. B→bS                  11. D→AB}
   4. A→aS                     8. B→bCAa
```

### Step 1: Eliminate ε-productions
After eliminating ε-productions, we get:

```
Non-terminals: A, B, C, D, S
Terminals: a, b
Start symbol: S
Productions:
  A -> a
  A -> aS
  A -> bCaCa
  A -> bCaa
  A -> baCa
  A -> baa
  B -> A
  B -> bAa
  B -> bCAa
  B -> bS
  C -> AB
  D -> AB
  S -> B
  S -> BC
  S -> bA
```

In this step, we identified that C is nullable (C → ε), and then generated new productions by removing C from all productions where it appears.

### Step 2: Eliminate Renaming
After eliminating unit productions (renaming), we get:

```
Non-terminals: A, B, C, D, S
Terminals: a, b
Start symbol: S
Productions:
  A -> a
  A -> aS
  A -> bCaCa
  A -> bCaa
  A -> baCa
  A -> baa
  B -> a
  B -> aS
  B -> bAa
  B -> bCAa
  B -> bCaCa
  B -> bCaa
  B -> bS
  B -> baCa
  B -> baa
  C -> AB
  D -> AB
  S -> BC
  S -> a
  S -> aS
  S -> bA
  S -> bAa
  S -> bCAa
  S -> bCaCa
  S -> bCaa
  S -> bS
  S -> baCa
  S -> baa
```

In this step, we replaced unit productions like B → A with the productions of A, and similarly for other unit productions.

### Step 3: Eliminate Inaccessible Symbols
After eliminating inaccessible symbols, we get:

```
Non-terminals: A, B, C, S
Terminals: a, b
Start symbol: S
Productions:
  A -> a
  A -> aS
  A -> bCaCa
  A -> bCaa
  A -> baCa
  A -> baa
  B -> a
  B -> aS
  B -> bAa
  B -> bCAa
  B -> bCaCa
  B -> bCaa
  B -> bS
  B -> baCa
  B -> baa
  C -> AB
  S -> BC
  S -> a
  S -> aS
  S -> bA
  S -> bAa
  S -> bCAa
  S -> bCaCa
  S -> bCaa
  S -> bS
  S -> baCa
  S -> baa
```

In this step, we identified that D is inaccessible (cannot be reached from the start symbol S), so it was removed from the grammar.

### Step 4: Eliminate Non-productive Symbols
After eliminating non-productive symbols, we get:

```
Non-terminals: A, B, C, S
Terminals: a, b
Start symbol: S
Productions:
  A -> a
  A -> aS
  A -> bCaCa
  A -> bCaa
  A -> baCa
  A -> baa
  B -> a
  B -> aS
  B -> bAa
  B -> bCAa
  B -> bCaCa
  B -> bCaa
  B -> bS
  B -> baCa
  B -> baa
  C -> AB
  S -> BC
  S -> a
  S -> aS
  S -> bA
  S -> bAa
  S -> bCAa
  S -> bCaCa
  S -> bCaa
  S -> bS
  S -> baCa
  S -> baa
```

In this case, all symbols are productive (can derive terminal strings), so no changes were made.

### Step 5: Convert to Chomsky Normal Form
Finally, after converting to CNF, we get:

```
Non-terminals: A, B, C, S, T_a, T_b, X_10, X_11, X_12, X_13, X_14, X_15, X_16, X_17, X_18, X_19, X_20, X_21, X_22, X_23, X_24, X_25, X_26, X_27, X_28, X_29, X_30, X_31, X_32, X_33, X_34, X_35, X_6, X_7, X_8, X_9
Terminals: a, b
Start symbol: S
Productions:
  A -> T_aS
  A -> T_bX_10
  A -> T_bX_12
  A -> T_bX_13
  A -> T_bX_8
  A -> a
  B -> T_aS
  B -> T_bS
  B -> T_bX_26
  B -> T_bX_27
  B -> T_bX_30
  B -> T_bX_32
  B -> T_bX_34
  B -> T_bX_35
  B -> a
  C -> AB
  S -> BC
  S -> T_aS
  S -> T_bA
  S -> T_bS
  S -> T_bX_15
  S -> T_bX_16
  S -> T_bX_19
  S -> T_bX_21
  S -> T_bX_23
  S -> T_bX_24
  S -> a
  T_a -> a
  T_b -> b
  X_10 -> CX_9
  X_11 -> CT_a
  X_12 -> T_aX_11
  X_13 -> T_aT_a
  X_14 -> AT_a
  X_15 -> CX_14
  X_16 -> AT_a
  X_17 -> CT_a
  X_18 -> T_aX_17
  X_19 -> CX_18
  X_20 -> T_aT_a
  X_21 -> CX_20
  X_22 -> CT_a
  X_23 -> T_aX_22
  X_24 -> T_aT_a
  X_25 -> AT_a
  X_26 -> CX_25
  X_27 -> AT_a
  X_28 -> CT_a
  X_29 -> T_aX_28
  X_30 -> CX_29
  X_31 -> T_aT_a
  X_32 -> CX_31
  X_33 -> CT_a
  X_34 -> T_aX_33
  X_35 -> T_aT_a
  X_6 -> CT_a
  X_7 -> T_aX_6
  X_8 -> CX_7
  X_9 -> T_aT_a
```

In this step, we:
1. Replaced terminals in productions with new non-terminals (T_a → a, T_b → b)
2. Broke down productions with more than two symbols into binary productions using new non-terminals (X_*)

## Conclusion
In this laboratory work, I successfully implemented a method for converting context-free grammars to Chomsky Normal Form. The implementation follows all the required steps and can handle any context-free grammar, not just the one from Variant 25.

The conversion to CNF is an important transformation for context-free grammars, as it simplifies the grammar structure while preserving the language it generates. This simplified form is particularly useful for parsing algorithms like the CYK algorithm, which relies on the grammar being in CNF.

The implementation is modular and well-structured, with each transformation step encapsulated in its own method. This makes the code easy to understand, maintain, and extend.

## References
1. [Chomsky Normal Form - Wikipedia](https://en.wikipedia.org/wiki/Chomsky_normal_form)
2. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, Languages, and Computation (3rd Edition). Addison-Wesley.
3. Sipser, M. (2012). Introduction to the Theory of Computation (3rd Edition). Cengage Learning.
